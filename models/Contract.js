const mongoose = require('mongoose');

const contractSchema = new mongoose.Schema({
    bid: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Bid',
        required: [true, 'Bid reference is required']
    },
    project: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Project',
        required: [true, 'Project reference is required']
    },
    customer: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: [true, 'Customer reference is required']
    },
    seller: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: [true, 'Seller reference is required']
    },
    // Cloudinary contract files
    customerSignedContract: {
        public_id: String,
        url: String,
        filename: String,
        originalName: String,
        bytes: Number,
        uploadedAt: Date,
        uploadedBy: { 
            type: String, 
            enum: ['customer', 'seller', 'admin'],
            default: 'customer'
        },
        ipAddress: String,
        mimeType: String,
        signatureDate: Date
    },
    sellerSignedContract: {
        public_id: String,
        url: String,
        filename: String,
        originalName: String,
        bytes: Number,
        uploadedAt: Date,
        uploadedBy: { 
            type: String, 
            enum: ['customer', 'seller', 'admin'],
            default: 'seller'
        },
        ipAddress: String,
        mimeType: String,
        signatureDate: Date
    },
    finalContract: {
        public_id: String,
        url: String,
        filename: String,
        bytes: Number,
        generatedAt: Date,
        mimeType: String,
        version: String
    },
    // Additional contract documents
    supportingDocuments: [{
        public_id: {
            type: String,
            required: true
        },
        url: {
            type: String,
            required: true
        },
        filename: String,
        originalName: String,
        documentType: {
            type: String,
            enum: ['addendum', 'amendment', 'certificate', 'insurance', 'other'],
            required: true
        },
        description: String,
        bytes: Number,
        uploadedAt: {
            type: Date,
            default: Date.now
        },
        uploadedBy: {
            type: String,
            enum: ['customer', 'seller', 'admin'],
            required: true
        }
    }],
    terms: {
        type: Map,
        of: mongoose.Schema.Types.Mixed,
        default: new Map()
    },
    status: {
        type: String,
        enum: ['draft', 'pending-customer', 'pending-seller', 'pending-admin', 'approved', 'rejected', 'cancelled', 'completed'],
        default: 'pending-customer'
    },
    adminApproved: {
        type: Boolean,
        default: false
    },
    adminApprovedAt: Date,
    approvedBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User'
    },
    adminNotes: {
        type: String,
        maxlength: [1000, 'Admin notes cannot exceed 1000 characters']
    },
    rejectionReason: {
        type: String,
        maxlength: [1000, 'Rejection reason cannot exceed 1000 characters']
    },
    version: {
        type: Number,
        default: 1
    },
    contractValue: {
        type: Number,
        required: true
    },
    paymentSchedule: [{
        milestone: String,
        amount: Number,
        dueDate: Date,
        status: {
            type: String,
            enum: ['pending', 'paid', 'overdue'],
            default: 'pending'
        },
        paidAt: Date
    }],
    autoGenerated: {
        type: Boolean,
        default: true
    },
    contractType: {
        type: String,
        enum: ['standard', 'premium', 'custom'],
        default: 'standard'
    },
    createdAt: {
        type: Date,
        default: Date.now
    },
    updatedAt: {
        type: Date,
        default: Date.now
    }
});

// Pre-save middleware
contractSchema.pre('save', function(next) {
    this.updatedAt = Date.now();
    
    // Auto-update status based on signed contracts
    if (this.customerSignedContract?.url && this.sellerSignedContract?.url) {
        this.status = 'pending-admin';
    } else if (this.customerSignedContract?.url && !this.sellerSignedContract?.url) {
        this.status = 'pending-seller';
    } else if (!this.customerSignedContract?.url && this.sellerSignedContract?.url) {
        this.status = 'pending-customer';
    }
    
    next();
});

// Instance methods
contractSchema.methods.addSupportingDocument = function(documentData) {
    this.supportingDocuments.push(documentData);
    return this.save();
};

contractSchema.methods.removeSupportingDocument = function(publicId) {
    this.supportingDocuments = this.supportingDocuments.filter(doc => doc.public_id !== publicId);
    return this.save();
};

contractSchema.methods.isComplete = function() {
    return !!(this.customerSignedContract?.url && this.sellerSignedContract?.url);
};

contractSchema.methods.isReadyForAdmin = function() {
    return this.isComplete() && this.status === 'pending-admin';
};

contractSchema.methods.markAsAdminApproved = function(adminId, notes = '') {
    this.status = 'completed';
    this.adminApproved = true;
    this.adminApprovedAt = new Date();
    this.approvedBy = adminId;
    this.adminNotes = notes;
    return this.save();
};

// Indexes
contractSchema.index({ bid: 1 });
contractSchema.index({ project: 1 });
contractSchema.index({ customer: 1, status: 1 });
contractSchema.index({ seller: 1, status: 1 });
contractSchema.index({ status: 1 });
contractSchema.index({ createdAt: -1 });
contractSchema.index({ status: 1, updatedAt: -1 });

module.exports = mongoose.model('Contract', contractSchema);