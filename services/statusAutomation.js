// services/statusAutomation.js - 100% WORKING VERSION
const cron = require('node-cron');
const Project = require('../models/Project');
const Bid = require('../models/Bid');
const Contract = require('../models/Contract');
const User = require('../models/User');
const Notice = require('../models/Notice');
const PDFGenerator = require('../services/pdfGenerator');
class StatusAutomationService {
    constructor() {
        this.isRunning = false;
    }

// services/statusAutomation.js - Enhanced contract initialization
 // Make sure this exists
// Replace the initializeContractForWinner method with this enhanced version
// Update the initializeContractForWinner method to ensure proper status:
async initializeContractForWinner(project, winningBid, results) {
    try {
        console.log('üìù Initializing contract for winning bid...');
        
        // Check if contract already exists
        const existingContract = await Contract.findOne({ bid: winningBid._id });
        if (existingContract) {
            console.log('Contract already exists, skipping initialization');
            return existingContract;
        }

        // Get customer and seller details
        const customer = await User.findById(project.customer);
        const seller = await User.findById(winningBid.seller);

        if (!customer || !seller) {
            throw new Error('Customer or seller not found for contract initialization');
        }

        console.log('üîÑ Generating contract templates...');
        
        // Generate contract templates
        const customerTemplate = await PDFGenerator.generateContract('customer', winningBid, project, customer, seller);
        const sellerTemplate = await PDFGenerator.generateContract('seller', winningBid, project, customer, seller);

        console.log('‚úÖ Contract templates generated:', {
            customerTemplate: customerTemplate ? 'Yes' : 'No',
            sellerTemplate: sellerTemplate ? 'Yes' : 'No'
        });

        // Create contract record - SET STATUS TO pending-customer (NOT auto-approved)
        const contract = new Contract({
            bid: winningBid._id,
            project: project._id,
            customer: project.customer,
            seller: winningBid.seller,
            contractValue: winningBid.amount,
            status: 'pending-customer', // ‚ùå NOT auto-approved - waits for customer upload
            currentStep: 1,
            autoGenerated: true,
            
            // Store generated templates
            customerTemplate: {
                public_id: customerTemplate.public_id,
                url: customerTemplate.secure_url,
                filename: `customer_contract_${winningBid._id}.pdf`,
                bytes: customerTemplate.bytes,
                generatedAt: new Date()
            },
            sellerTemplate: {
                public_id: sellerTemplate.public_id,
                url: sellerTemplate.secure_url,
                filename: `seller_contract_${winningBid._id}.pdf`,
                bytes: sellerTemplate.bytes,
                generatedAt: new Date()
            },
            
            // Store contract terms
            terms: new Map([
                ['projectTitle', project.title],
                ['projectDescription', project.description],
                ['contractValue', winningBid.amount.toString()],
                ['startDate', project.timeline.startDate.toISOString()],
                ['endDate', project.timeline.endDate.toISOString()],
                ['category', project.category],
                ['customerName', customer.name],
                ['sellerName', seller.companyName || seller.name],
                ['customerEmail', customer.email],
                ['sellerEmail', seller.email]
            ]),
            
            createdAt: new Date(),
            updatedAt: new Date()
        });

        await contract.save();
        console.log(`‚úÖ Contract initialized (pending customer): ${contract._id}`);

        // Create notifications - EMPHASIZE MANUAL PROCESS
        await this.createNotice(
            `Contract Ready - ${project.title}`,
            `Congratulations! Your bid has been selected. Please wait for the customer to upload their signed contract first. Once they upload, you'll be able to download your template and upload your signed contract.`,
            'seller',
            'success',
            winningBid.seller._id
        );

        await this.createNotice(
            `Contract Ready - ${project.title}`,
            `A seller has been selected for your project. Please download the contract template, sign it, and upload the signed version to proceed. After you upload, the seller will upload their contract, and then admin will manually approve the final contract.`,
            'customer',
            'info',
            project.customer
        );

        // Notify admin that a new contract needs monitoring
        await this.createNotice(
            `New Contract Created - ${project.title}`,
            `A new contract has been created and is waiting for customer upload. You'll need to manually approve this contract once both parties have uploaded their signed contracts.`,
            'admin',
            'info'
        );

        return contract;

    } catch (error) {
        console.error('‚ùå Contract initialization error:', error);
        throw error;
    }
}
// Also update the selectWinners method to ensure proper contract initialization:
async selectWinners(results, now) {
    try {
        const projectsForWinnerSelection = await Project.find({
            'bidSettings.isActive': false,
            'selectedBid': { $exists: false },
            status: 'in-progress'
        });

        console.log(`üîç Found ${projectsForWinnerSelection.length} projects for winner selection`);

        for (const project of projectsForWinnerSelection) {
            try {
                console.log(`\nüéØ Processing winner selection for: ${project.title}`);
                
                const bids = await Bid.find({ project: project._id })
                    .populate('seller', 'name email companyName phone taxId')
                    .sort({ amount: -1 });

                console.log(`üí∞ Found ${bids.length} bids for project`);

                const submittedBids = bids.filter(bid => bid.status === 'submitted');
                console.log(`üìù Valid submitted bids: ${submittedBids.length}`);

                if (submittedBids.length === 0) {
                    console.log('‚ö†Ô∏è No submitted bids - marking as failed');
                    await Project.findByIdAndUpdate(
                        project._id,
                        { 
                            status: 'failed',
                            failedAt: now 
                        },
                        { runValidators: false }
                    );
                    continue;
                }

                // Select winner (highest bid)
                const winningBid = submittedBids[0];
                
                console.log(`üèÜ Winner selected: ${winningBid.seller?.name} - $${winningBid.amount}`);

                // Update winning bid
                winningBid.status = 'won';
                winningBid.autoWon = true;
                winningBid.wonAt = now;
                winningBid.updatedAt = now;
                await winningBid.save();
                results.bidsUpdated++;

                // Update losing bids
                const losingBids = submittedBids.slice(1);
                if (losingBids.length > 0) {
                    await Bid.updateMany(
                        { _id: { $in: losingBids.map(bid => bid._id) } },
                        { 
                            status: 'lost',
                            lostAt: now,
                            updatedAt: now
                        }
                    );
                    results.bidsUpdated += losingBids.length;
                    console.log(`‚ùå Marked ${losingBids.length} bids as lost`);
                }

                // Update project
                await Project.findByIdAndUpdate(
                    project._id,
                    {
                        selectedBid: winningBid._id,
                        winnerSelectedAt: now,
                        status: 'awarded'
                    },
                    { runValidators: false }
                );
                results.winnersSelected++;

                // ‚úÖ INITIALIZE CONTRACT (but don't auto-approve)
                await this.initializeContractForWinner(project, winningBid, results);

                console.log(`‚úÖ Winner selection completed for: ${project.title}`);

            } catch (error) {
                console.error(`‚ùå Error selecting winner for ${project.title}:`, error.message);
                results.validationErrors++;
            }
        }
    } catch (error) {
        console.error('‚ùå Winner selection error:', error);
    }
}







    // üéØ COMPLETE PROJECT LIFECYCLE AUTOMATION - FIXED
    async updateAllProjectStatuses() {
        try {
            console.log('üîÑ === COMPLETE PROJECT LIFECYCLE AUTOMATION STARTED ===');
            const now = new Date();
            
            let results = {
                draftedToActive: 0,
                biddingStarted: 0,
                biddingClosed: 0,
                winnersSelected: 0,
                bidsUpdated: 0,
                contractsCreated: 0,
                contractsCompleted: 0,
                projectsCompleted: 0,
                certificatesGenerated: 0,
                expiredProjects: 0,
                validationErrors: 0
            };

            // üîÑ PHASE 1: PROJECT ACTIVATION
            await this.activateDraftedProjects(results, now);
            
            // üîÑ PHASE 2: BIDDING MANAGEMENT - FIXED
            await this.manageBiddingProcess(results, now);
            
            // üîÑ PHASE 3: WINNER SELECTION - FIXED
            await this.selectWinners(results, now);
            
            // üîÑ PHASE 4: CONTRACT MANAGEMENT
            await this.manageContracts(results, now);
            
            // üîÑ PHASE 5: PROJECT COMPLETION - FIXED
            await this.completeProjects(results, now);
            
            // üîÑ PHASE 6: CLEANUP EXPIRED - FIXED
            await this.cleanupExpiredProjects(results, now);

            console.log('\nüìä === COMPLETE AUTOMATION SUMMARY ===');
            Object.entries(results).forEach(([key, value]) => {
                console.log(`üìà ${key}: ${value}`);
            });
            
            return results;

        } catch (error) {
            console.error('‚ùå Complete automation error:', error);
            throw error;
        }
    }

    // üîÑ PHASE 1: PROJECT ACTIVATION
    async activateDraftedProjects(results, now) {
        try {
            const draftedProjects = await Project.find({
                status: 'drafted',
                'timeline.startDate': { $lte: now }
            });

            for (const project of draftedProjects) {
                try {
                    // üî• FIX: Use findByIdAndUpdate to bypass validation
                    await Project.findByIdAndUpdate(
                        project._id,
                        {
                            status: 'in-progress',
                            isPublic: true,
                            'bidSettings.isActive': true,
                            autoActivated: true,
                            updatedAt: now
                        },
                        { runValidators: false } // ‚ö†Ô∏è SKIP VALIDATION
                    );
                    
                    results.draftedToActive++;
                    console.log(`‚úÖ Activated drafted project: ${project.title}`);
                    
                    await this.createNotice(
                        `Project "${project.title}" is now active and accepting bids`,
                        'Project is now live and accepting bids from sellers.',
                        'seller',
                        'info'
                    );
                } catch (error) {
                    console.error(`‚ùå Failed to activate project ${project.title}:`, error.message);
                    results.validationErrors++;
                }
            }
        } catch (error) {
            console.error('‚ùå Project activation error:', error);
        }
    }

    // üîÑ PHASE 2: BIDDING MANAGEMENT - FIXED
    async manageBiddingProcess(results, now) {
        try {
            // Start bidding for projects that reached start date
            const projectsToStart = await Project.find({
                status: 'in-progress',
                'bidSettings.isActive': false,
                'timeline.startDate': { $lte: now }
            });

            for (const project of projectsToStart) {
                try {
                    await Project.findByIdAndUpdate(
                        project._id,
                        {
                            'bidSettings.isActive': true,
                            updatedAt: now
                        },
                        { runValidators: false }
                    );
                    
                    results.biddingStarted++;
                    console.log(`‚úÖ Started bidding for project: ${project.title}`);
                } catch (error) {
                    console.error(`‚ùå Failed to start bidding for ${project.title}:`, error.message);
                    results.validationErrors++;
                }
            }

            // Close bidding for ended projects - FIXED
            const projectsToClose = await Project.find({
                'bidSettings.isActive': true,
                'bidSettings.bidEndDate': { $lte: now }
            });

            for (const project of projectsToClose) {
                try {
                    // üî• FIX: Use findByIdAndUpdate to bypass validation
                    await Project.findByIdAndUpdate(
                        project._id,
                        {
                            'bidSettings.isActive': false,
                            biddingEndedAt: now,
                            updatedAt: now
                        },
                        { runValidators: false } // ‚ö†Ô∏è SKIP VALIDATION
                    );
                    
                    results.biddingClosed++;
                    console.log(`‚úÖ Closed bidding for project: ${project.title}`);
                    
                    await this.createNotice(
                        `Bidding closed for "${project.title}"`,
                        'The bidding period has ended. Winner selection in progress.',
                        'seller',
                        'warning'
                    );
                } catch (error) {
                    console.error(`‚ùå Failed to close bidding for ${project.title}:`, error.message);
                    results.validationErrors++;
                }
            }
        } catch (error) {
            console.error('‚ùå Bidding management error:', error);
        }
    }

   

  async manageContracts(results, now) {
    try {
        const contracts = await Contract.find({
            status: { $in: ['pending-customer', 'pending-seller', 'pending-admin'] }
        }).populate('project').populate('seller').populate('customer');

        console.log(`üìÑ Managing ${contracts.length} contracts`);

        for (const contract of contracts) {
            try {
                switch (contract.status) {
                    case 'pending-customer':
                        if (contract.customerSignedContract && contract.customerSignedContract.url) {
                            contract.status = 'pending-seller';
                            contract.updatedAt = now;
                            await contract.save();
                            
                            console.log(`‚úÖ Contract moved to pending-seller: ${contract.project.title}`);
                            
                            // Notify seller that customer has uploaded
                            await this.createNotice(
                                `Customer Contract Uploaded - ${contract.project.title}`,
                                'Customer has uploaded their signed contract. Please download the template, sign it, and upload your signed version.',
                                'seller',
                                'info',
                                contract.seller._id
                            );
                        }
                        break;

                    case 'pending-seller':
                        if (contract.sellerSignedContract && contract.sellerSignedContract.url) {
                            contract.status = 'pending-admin';
                            contract.updatedAt = now;
                            await contract.save();
                            
                            console.log(`‚úÖ Contract moved to pending-admin: ${contract.project.title}`);
                            
                            // Notify admin that contract is ready for review
                            await this.createNotice(
                                `Contract Ready for Review - ${contract.project.title}`,
                                `Both customer and seller have uploaded signed contracts. Please review and approve the contract.`,
                                'admin',
                                'warning'
                            );
                            
                            // Notify both parties that contract is with admin
                            await this.createNotice(
                                `Contract Under Review - ${contract.project.title}`,
                                'Both contracts have been uploaded and are now with admin for final approval.',
                                'customer',
                                'info',
                                contract.customer._id
                            );
                            
                            await this.createNotice(
                                `Contract Under Review - ${contract.project.title}`,
                                'Both contracts have been uploaded and are now with admin for final approval.',
                                'seller',
                                'info',
                                contract.seller._id
                            );
                        }
                        break;

                    case 'pending-admin':
                        // ‚ùå REMOVED AUTO-APPROVAL - WAITING FOR MANUAL ADMIN APPROVAL
                        // Contract stays in pending-admin until admin manually approves
                        console.log(`‚è≥ Contract waiting for admin approval: ${contract.project.title}`);
                        break;
                }
            } catch (error) {
                console.error(`‚ùå Error managing contract ${contract._id}:`, error.message);
                results.validationErrors++;
            }
        }
    } catch (error) {
        console.error('‚ùå Contract management error:', error);
    }
}

    // üîÑ PHASE 5: PROJECT COMPLETION - FIXED
    async completeProjects(results, now) {
        try {
            const projectsToComplete = await Project.find({
                status: 'contract-approved',
                'timeline.endDate': { $lte: now }
            });

            console.log(`üèÅ Found ${projectsToComplete.length} projects to complete`);

            for (const project of projectsToComplete) {
                try {
                    // üî• FIX: Use findByIdAndUpdate to bypass validation
                    await Project.findByIdAndUpdate(
                        project._id,
                        {
                            status: 'completed',
                            completedAt: now,
                            updatedAt: now
                        },
                        { runValidators: false }
                    );
                    
                    results.projectsCompleted++;

                    // Update winning bid status
                    await Bid.findByIdAndUpdate(project.selectedBid, {
                        status: 'completed',
                        completedAt: now,
                        updatedAt: now
                    });

                    // Generate certificate
                    await this.generateCertificate(project, results);

                    console.log(`‚úÖ Project completed: ${project.title}`);

                } catch (error) {
                    console.error(`‚ùå Error completing project ${project.title}:`, error.message);
                    results.validationErrors++;
                }
            }
        } catch (error) {
            console.error('‚ùå Project completion error:', error);
        }
    }

    // üîÑ PHASE 6: CLEANUP EXPIRED - FIXED
    async cleanupExpiredProjects(results, now) {
        try {
            const expiredDate = new Date(now.getTime() - (30 * 24 * 60 * 60 * 1000));
            
            const expiredProjects = await Project.find({
                status: { $in: ['completed', 'failed', 'cancelled'] },
                updatedAt: { $lte: expiredDate }
            });

            for (const project of expiredProjects) {
                try {
                    await Project.findByIdAndUpdate(
                        project._id,
                        {
                            isArchived: true,
                            archivedAt: now
                        },
                        { runValidators: false }
                    );
                    
                    results.expiredProjects++;
                    console.log(`üóëÔ∏è Archived expired project: ${project.title}`);
                } catch (error) {
                    console.error(`‚ùå Error archiving project ${project.title}:`, error.message);
                    results.validationErrors++;
                }
            }
        } catch (error) {
            console.error('‚ùå Cleanup error:', error);
        }
    }

    // üéØ HELPER FUNCTIONS
    async createContract(project, winningBid, results) {
        try {
            const existingContract = await Contract.findOne({ bid: winningBid._id });
            if (!existingContract) {
                const contract = new Contract({
                    bid: winningBid._id,
                    project: project._id,
                    customer: project.customer,
                    seller: winningBid.seller,
                    contractValue: winningBid.amount,
                    status: 'pending-customer',
                    autoGenerated: true,
                    createdAt: new Date(),
                    updatedAt: new Date()
                });
                await contract.save();
                results.contractsCreated++;
                console.log(`üìù Contract created: ${contract._id}`);
                return contract;
            }
            return existingContract;
        } catch (error) {
            console.error('‚ùå Contract creation error:', error);
        }
    }

    async generateCertificate(project, results) {
        try {
            const winningBid = await Bid.findById(project.selectedBid);
            if (winningBid && !winningBid.certificateGenerated) {
                winningBid.certificateGenerated = true;
                winningBid.certificateUrl = `/certificates/${project._id}_${winningBid._id}.pdf`;
                winningBid.certificateGeneratedAt = new Date();
                await winningBid.save();
                
                results.certificatesGenerated++;
                console.log(`üìú Certificate generated for: ${project.title}`);
            }
        } catch (error) {
            console.error('‚ùå Certificate generation error:', error);
        }
    }

    async createNotice(title, content, audience, type, specificUser = null) {
        try {
            const notice = new Notice({
                title,
                content,
                targetAudience: audience,
                specificUser: specificUser,
                noticeType: type,
                isActive: true,
                startDate: new Date(),
                endDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
                createdAt: new Date(),
                updatedAt: new Date()
            });
            await notice.save();
            console.log(`üì¢ Notice created: ${title}`);
        } catch (error) {
            console.error('‚ùå Notice creation error:', error);
        }
    }

    // üöÄ START AUTOMATION SERVICE
    start() {
        if (this.isRunning) {
            console.log('‚ö†Ô∏è Status automation service already running');
            return;
        }
        
        // Run every 2 minutes
        cron.schedule('*/2 * * * *', async () => {
            try {
                console.log('\n‚è∞ === RUNNING COMPLETE AUTOMATION CYCLE ===');
                await this.updateAllProjectStatuses();
                console.log('‚úÖ === AUTOMATION CYCLE COMPLETED ===\n');
            } catch (error) {
                console.error('‚ùå Automation cycle error:', error);
            }
        });

        console.log('üöÄ FIXED Status automation service started (runs every 2 minutes)');
        this.isRunning = true;
    }
// Add to existing StatusAutomationService class

// Enhanced contract creation with PDF generation
async createContractWithPDF(project, winningBid, results) {
    try {
        const existingContract = await Contract.findOne({ bid: winningBid._id });
        if (existingContract) {
            console.log(`Contract already exists for bid ${winningBid._id}`);
            return existingContract;
        }

        // Get customer and seller details
        const customer = await User.findById(project.customer);
        const seller = await User.findById(winningBid.seller);

        if (!customer || !seller) {
            throw new Error('Customer or seller not found');
        }

        // Generate contract templates
        console.log('üìÑ Generating contract templates...');
        const customerTemplate = await PDFGenerator.generateContract('customer', winningBid, project, customer, seller);
        const sellerTemplate = await PDFGenerator.generateContract('seller', winningBid, project, customer, seller);

        // Create contract record
        const contract = new Contract({
            bid: winningBid._id,
            project: project._id,
            customer: project.customer,
            seller: winningBid.seller,
            contractValue: winningBid.amount,
            status: 'pending-customer',
            autoGenerated: true,
            
            // Store template URLs for download
            customerTemplate: {
                public_id: customerTemplate.public_id,
                url: customerTemplate.secure_url,
                filename: `customer_contract_${winningBid._id}.pdf`,
                generatedAt: new Date()
            },
            sellerTemplate: {
                public_id: sellerTemplate.public_id,
                url: sellerTemplate.secure_url,
                filename: `seller_contract_${winningBid._id}.pdf`,
                generatedAt: new Date()
            },
            
            terms: new Map([
                ['projectTitle', project.title],
                ['projectDescription', project.description],
                ['contractValue', winningBid.amount.toString()],
                ['timeline', `${project.timeline.startDate} to ${project.timeline.endDate}`],
                ['category', project.category]
            ]),
            
            createdAt: new Date(),
            updatedAt: new Date()
        });

        await contract.save();
        results.contractsCreated++;
        console.log(`‚úÖ Contract created with templates: ${contract._id}`);

        // Create notices for both parties
        await this.createNotice(
            `Contract Ready - ${project.title}`,
            `Congratulations! Your bid has been selected. Please download the contract template, sign it, and upload the signed version.`,
            'seller',
            'success',
            winningBid.seller._id
        );

        await this.createNotice(
            `Contract Ready - ${project.title}`,
            `A seller has been selected for your project. Please download the contract template, sign it, and upload the signed version to proceed.`,
            'customer',
            'info',
            project.customer
        );

        return contract;
    } catch (error) {
        console.error('‚ùå Contract creation with PDF error:', error);
        throw error;
    }
}

// Enhanced project completion with certificate generation
async completeProjectWithCertificate(project, results) {
    try {
        const winningBid = await Bid.findById(project.selectedBid)
            .populate('seller')
            .populate('customer');
            
        const customer = await User.findById(project.customer);
        const contract = await Contract.findOne({ project: project._id });

        if (!winningBid || !customer) {
            throw new Error('Winning bid or customer not found');
        }

        // Generate completion certificate
        console.log('üìú Generating completion certificate...');
        const certificate = await PDFGenerator.generateContract('certificate', winningBid, project, customer, winningBid.seller);

        // Update bid with certificate
        winningBid.certificateGenerated = true;
        winningBid.certificateUrl = certificate.secure_url;
        winningBid.certificatePublicId = certificate.public_id;
        winningBid.certificateGeneratedAt = new Date();
        winningBid.status = 'completed';
        await winningBid.save();

        // Update contract
        if (contract) {
            contract.finalContract = {
                public_id: certificate.public_id,
                url: certificate.secure_url,
                filename: `completion_certificate_${project._id}.pdf`,
                generatedAt: new Date()
            };
            await contract.save();
        }

        results.certificatesGenerated++;
        console.log(`‚úÖ Certificate generated for project: ${project.title}`);

        // Create completion notices
        await this.createNotice(
            `Project Completed - ${project.title}`,
            `Your project has been completed successfully! Download your completion certificate.`,
            'customer',
            'success',
            project.customer
        );

        await this.createNotice(
            `Project Completed - ${project.title}`,
            `Congratulations! You have successfully completed the project. Download your completion certificate.`,
            'seller',
            'success',
            winningBid.seller._id
        );

    } catch (error) {
        console.error('‚ùå Project completion with certificate error:', error);
    }
}

// Update the existing winner selection method
async selectWinners(results, now) {
    try {
        const projectsForWinnerSelection = await Project.find({
            'bidSettings.isActive': false,
            'selectedBid': { $exists: false },
            status: 'in-progress'
        });

        console.log(`üîç Found ${projectsForWinnerSelection.length} projects for winner selection`);

        for (const project of projectsForWinnerSelection) {
            try {
                console.log(`\nüéØ Processing winner selection for: ${project.title}`);
                
                const bids = await Bid.find({ project: project._id })
                    .populate('seller', 'name email companyName phone taxId')
                    .sort({ amount: -1 });

                console.log(`üí∞ Found ${bids.length} bids for project`);

                const submittedBids = bids.filter(bid => bid.status === 'submitted');
                console.log(`üìù Valid submitted bids: ${submittedBids.length}`);

                if (submittedBids.length === 0) {
                    console.log('‚ö†Ô∏è No submitted bids - marking as failed');
                    await Project.findByIdAndUpdate(
                        project._id,
                        { 
                            status: 'failed',
                            failedAt: now 
                        },
                        { runValidators: false }
                    );
                    continue;
                }

                // Select winner (highest bid)
                const winningBid = submittedBids[0];
                
                console.log(`üèÜ Winner selected: ${winningBid.seller?.name} - $${winningBid.amount}`);

                // Update winning bid
                winningBid.status = 'won';
                winningBid.autoWon = true;
                winningBid.wonAt = now;
                winningBid.updatedAt = now;
                await winningBid.save();
                results.bidsUpdated++;

                // Update losing bids
                const losingBids = submittedBids.slice(1);
                if (losingBids.length > 0) {
                    await Bid.updateMany(
                        { _id: { $in: losingBids.map(bid => bid._id) } },
                        { 
                            status: 'lost',
                            lostAt: now,
                            updatedAt: now
                        }
                    );
                    results.bidsUpdated += losingBids.length;
                    console.log(`‚ùå Marked ${losingBids.length} bids as lost`);
                }

                // Update project
                await Project.findByIdAndUpdate(
                    project._id,
                    {
                        selectedBid: winningBid._id,
                        winnerSelectedAt: now,
                        status: 'awarded'
                    },
                    { runValidators: false }
                );
                results.winnersSelected++;

                // Create contract WITH PDF TEMPLATES
                await this.createContractWithPDF(project, winningBid, results);

                console.log(`‚úÖ Winner selection completed for: ${project.title}`);

            } catch (error) {
                console.error(`‚ùå Error selecting winner for ${project.title}:`, error.message);
                results.validationErrors++;
            }
        }
    } catch (error) {
        console.error('‚ùå Winner selection error:', error);
    }
}

// Update project completion phase
async completeProjects(results, now) {
    try {
        const projectsToComplete = await Project.find({
            status: 'contract-approved',
            'timeline.endDate': { $lte: now }
        });

        console.log(`üèÅ Found ${projectsToComplete.length} projects to complete`);

        for (const project of projectsToComplete) {
            try {
                // Update project status
                await Project.findByIdAndUpdate(
                    project._id,
                    {
                        status: 'completed',
                        completedAt: now,
                        updatedAt: now
                    },
                    { runValidators: false }
                );
                
                results.projectsCompleted++;

                // Generate completion certificate
                await this.completeProjectWithCertificate(project, results);

                console.log(`‚úÖ Project completed: ${project.title}`);

            } catch (error) {
                console.error(`‚ùå Error completing project ${project.title}:`, error.message);
                results.validationErrors++;
            }
        }
    } catch (error) {
        console.error('‚ùå Project completion error:', error);
    }
}
    // üõ†Ô∏è MANUAL TRIGGER FOR TESTING
    async manualUpdate(projectId = null) {
        try {
            console.log('üîÑ === MANUAL AUTOMATION TRIGGERED ===');
            
            if (projectId) {
                console.log(`üîß Processing specific project: ${projectId}`);
                const project = await Project.findById(projectId);
                if (project) {
                    // Force bid end date to past for immediate testing
                    await Project.findByIdAndUpdate(
                        projectId,
                        {
                            'bidSettings.bidEndDate': new Date(Date.now() - 24 * 60 * 60 * 1000)
                        },
                        { runValidators: false }
                    );
                    console.log(`üîß Set bid end date to past for: ${project.title}`);
                }
            }
            
            const result = await this.updateAllProjectStatuses();
            return {
                success: true,
                message: 'Manual automation completed',
                data: result
            };
        } catch (error) {
            console.error('‚ùå Manual automation error:', error);
            return {
                success: false,
                message: 'Automation failed',
                error: error.message
            };
        }
    }
}

module.exports = new StatusAutomationService();