const PDFDocument = require('pdfkit');
const Contract = require('../models/Contract');
const cloudinary = require('../config/cloudinary');

class CertificateService {
    static async generateCertificate(contractId) {
        try {
            const contract = await Contract.findById(contractId)
                .populate('project')
                .populate('customer')
                .populate('seller')
                .populate('bid');

            const doc = new PDFDocument({ margin: 50 });
            const chunks = [];

            doc.on('data', (chunk) => chunks.push(chunk));

            return new Promise((resolve, reject) => {
                doc.on('end', async () => {
                    try {
                        const pdfBuffer = Buffer.concat(chunks);
                        
                        // Upload to Cloudinary
                        const result = await new Promise((resolve, reject) => {
                            cloudinary.uploader.upload_stream(
                                {
                                    resource_type: 'raw',
                                    folder: 'propload/certificates',
                                    public_id: `certificate-${contractId}`
                                },
                                (error, result) => {
                                    if (error) reject(error);
                                    else resolve(result);
                                }
                            ).end(pdfBuffer);
                        });

                        // Update contract with certificate URL
                        contract.certificateUrl = result.secure_url;
                        contract.certificateGenerated = true;
                        await contract.save();

                        resolve(result.secure_url);
                    } catch (error) {
                        reject(error);
                    }
                });

                doc.on('error', reject);

                // Certificate content
                this.generateCertificateContent(doc, contract);
                doc.end();
            });
        } catch (error) {
            throw error;
        }
    }

    static generateCertificateContent(doc, contract) {
        // Header
        doc.fontSize(24)
           .text('CERTIFICATE OF AGREEMENT', { align: 'center' })
           .moveDown();

        doc.fontSize(16)
           .text('This certifies that the following parties have entered into a binding agreement:', { align: 'center' })
           .moveDown(2);

        // Parties information
        doc.fontSize(14)
           .text('PARTIES:', { underline: true })
           .moveDown(0.5);

        doc.text(`Customer: ${contract.customer.name}`)
           .text(`Email: ${contract.customer.email}`)
           .moveDown();

        doc.text(`Service Provider: ${contract.seller.name}`)
           .text(`Company: ${contract.seller.companyName || 'N/A'}`)
           .text(`Email: ${contract.seller.email}`)
           .moveDown();

        // Project details
        doc.text('PROJECT DETAILS:', { underline: true })
           .moveDown(0.5);

        doc.text(`Project: ${contract.project.title}`)
           .text(`Category: ${contract.project.category}`)
           .text(`Agreed Amount: $${contract.bid.amount}`)
           .text(`Timeline: ${contract.project.timeline.startDate.toDateString()} - ${contract.project.timeline.endDate.toDateString()}`)
           .moveDown();

        // Footer
        doc.moveDown(2);
        doc.fontSize(10)
           .text('This certificate was automatically generated by Propload Platform.', { align: 'center' })
           .text(`Certificate ID: ${contract._id}`, { align: 'center' })
           .text(`Generated on: ${new Date().toDateString()}`, { align: 'center' });
    }
}

module.exports = CertificateService;